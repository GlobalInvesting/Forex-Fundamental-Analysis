name: Update FX Performance (1M momentum)
on:
  schedule:
    - cron: '0 7 * * *'
  workflow_dispatch:

jobs:
  update-fx-performance:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install requests --break-system-packages

      - name: Create directory
        run: mkdir -p fx-performance

      - name: Fetch 1M FX performance
        run: |
          python3 << 'EOFPYTHON'
          import requests
          import json
          import time
          from datetime import date, timedelta

          HEADERS = {'User-Agent': 'Mozilla/5.0 (compatible; ForexDashboard/1.0)'}

          CURRENCIES = ['EUR', 'GBP', 'JPY', 'AUD', 'CAD', 'CHF', 'NZD']

          today = date.today()

          # CORRECCI√ìN: Usar ayer como "hoy confiable".
          # Frankfurter usa ECB reference rates publicados a las 16:00 CET.
          # Si el workflow corre antes de esa hora, 'today' puede no tener dato
          # confirmado y Frankfurter devuelve el d√≠a anterior de forma inconsistente.
          # Usando yesterday expl√≠citamente garantizamos coherencia temporal entre
          # todas las divisas en cada ejecuci√≥n.
          yesterday = today - timedelta(days=1)
          date_30d  = yesterday - timedelta(days=30)
          date_7d   = yesterday - timedelta(days=7)

          today_str = yesterday.isoformat()   # "hoy confiable"
          d30_str   = date_30d.isoformat()
          d7_str    = date_7d.isoformat()

          print(f"Fetching FX performance: {d30_str} ‚Üí {today_str} (using yesterday as confirmed ECB date)")

          def fetch_rate_on_date(currency, date_str, retries=3, backoff=2):
              """
              Fetch USD/{currency} rate on a specific date via Frankfurter.
              Returns units of currency per 1 USD (i.e. how many JPY/EUR/etc per dollar).

              Frankfurter usa ECB reference rates publicados a las 16:00 CET.
              Si pedimos la fecha de hoy antes de esa hora, puede devolver
              el dato del d√≠a anterior de forma inconsistente entre divisas.
              Para evitar este desajuste, las fechas se normalizan en el bloque
              superior (usando yesterday). Esta funci√≥n acepta la fecha ya normalizada.

              En caso de d√≠a no h√°bil (fin de semana, festivo), Frankfurter
              devuelve autom√°ticamente el √∫ltimo dato disponible ‚Äî lo aceptamos.
              """
              url = f"https://api.frankfurter.app/{date_str}?from=USD&to={currency}"
              for attempt in range(1, retries + 1):
                  try:
                      r = requests.get(url, headers=HEADERS, timeout=12)
                      if r.ok:
                          data = r.json()
                          rate = data.get('rates', {}).get(currency)
                          if rate:
                              # Loguear la fecha real devuelta por Frankfurter (puede diferir
                              # de date_str si ese d√≠a no era h√°bil)
                              actual_date = data.get('date', date_str)
                              if actual_date != date_str:
                                  print(f"  Note: {currency} on {date_str} ‚Üí Frankfurter returned {actual_date} (non-trading day adjusted)")
                              return float(rate)
                          print(f"  Warning: {currency} on {date_str}: rate not in response (keys: {list(data.get('rates',{}).keys())})")
                      else:
                          print(f"  Warning: {currency} on {date_str}: HTTP {r.status_code} (attempt {attempt}/{retries})")
                  except Exception as e:
                      print(f"  Warning: {currency} on {date_str}: {e} (attempt {attempt}/{retries})")

                  if attempt < retries:
                      sleep_s = backoff ** (attempt - 1)  # 1s, 2s
                      print(f"  Retrying in {sleep_s}s...")
                      time.sleep(sleep_s)

              print(f"  ERROR: All {retries} attempts failed for {currency} on {date_str}")
              return None

          def calc_performance(currency, rate_now, rate_before):
              """
              Calculate % change in currency value (appreciation = positive).

              Si USD/CCY rate baja ‚Üí moneda se APRECI√ì vs USD ‚Üí resultado positivo.
              Si USD/CCY rate sube ‚Üí moneda se DEPRECI√ì vs USD ‚Üí resultado negativo.

              F√≥rmula: (rate_before / rate_now - 1) * 100
              Ejemplo: USD/JPY era 158, ahora 145 ‚Üí yen apreci√≥ 8.3% ‚Üí positivo.
              Ejemplo: USD/EUR era 0.95, ahora 0.92 ‚Üí EUR apreci√≥ 3.3% ‚Üí positivo.
              """
              if rate_now is None or rate_before is None:
                  return None
              if rate_before == 0 or rate_now == 0:
                  return None
              perf = (rate_before / rate_now - 1.0) * 100.0
              return round(perf, 4)

          results = {}

          for currency in CURRENCIES:
              print(f"\nProcessing {currency}...")

              rate_now = fetch_rate_on_date(currency, today_str)
              rate_30d = fetch_rate_on_date(currency, d30_str)
              rate_7d  = fetch_rate_on_date(currency, d7_str)

              print(f"  Now ({today_str}): {rate_now}")
              print(f"  30d ago ({d30_str}): {rate_30d}")
              print(f"  7d ago ({d7_str}): {rate_7d}")

              perf_1m = calc_performance(currency, rate_now, rate_30d)
              perf_1w = calc_performance(currency, rate_now, rate_7d)

              results[currency] = {
                  'fxPerformance1M': perf_1m,
                  'fxPerformance1W': perf_1w,
                  'rateNow':    rate_now,
                  'rate30dAgo': rate_30d,
                  'rate7dAgo':  rate_7d,
                  'date': today_str,
                  'source': 'Frankfurter API (ECB reference rates) ‚Äî date normalized to yesterday'
              }

              print(f"  1M perf: {perf_1m}%  |  1W perf: {perf_1w}%")

          # USD: calculado como inverso ponderado DXY
          # Pesos oficiales del √≠ndice DXY (ICE):
          #   EUR 57.6% | JPY 13.6% | GBP 11.9% | CAD 9.1% | CHF 3.6% | AUD 2.1% | NZD 2.1%
          # El peso igual previo (14.3% por divisa) sobreestimaba JPY/AUD/CAD
          # y subestimaba EUR. Pesos DXY reales reducen error en ~1pp.
          DXY_WEIGHTS = {
              'EUR': 0.576, 'JPY': 0.136, 'GBP': 0.119,
              'CAD': 0.091, 'CHF': 0.036, 'AUD': 0.021, 'NZD': 0.021
          }

          available_for_usd = [
              c for c in ['EUR', 'JPY', 'GBP', 'CAD', 'CHF', 'AUD', 'NZD']
              if results.get(c, {}).get('fxPerformance1M') is not None
          ]
          total_w = sum(DXY_WEIGHTS.get(c, 0) for c in available_for_usd)

          if total_w > 0:
              usd_perf = 0.0
              for c in available_for_usd:
                  perf = results[c]['fxPerformance1M']
                  w = DXY_WEIGHTS.get(c, 0) / total_w  # renormalizar si falta alguna divisa
                  usd_perf -= perf * w                  # USD se mueve inverso al resto
              usd_perf = round(usd_perf, 4)
              print(f"\nUSD 1M perf (DXY-weighted, {len(available_for_usd)}/{len(CURRENCIES)} currencies): {usd_perf}%")
          else:
              usd_perf = None
              print("\nUSD 1M perf: None (no currency data available)")

          results['USD'] = {
              'fxPerformance1M': usd_perf,
              'fxPerformance1W': None,
              'rateNow':    1.0,
              'rate30dAgo': 1.0,
              'rate7dAgo':  1.0,
              'date': today_str,
              'source': 'Computed as DXY-weighted inverse of currency basket (pesos ICE oficiales)'
          }

          # Guardar archivos individuales
          import os
          os.makedirs('fx-performance', exist_ok=True)

          all_currencies = ['USD'] + CURRENCIES
          for curr in all_currencies:
              if curr in results:
                  with open(f'fx-performance/{curr}.json', 'w') as f:
                      json.dump(results[curr], f, indent=2)
                  status = '‚úì' if results[curr]['fxPerformance1M'] is not None else '‚úó NULL'
                  print(f"Saved fx-performance/{curr}.json: 1M={results[curr]['fxPerformance1M']}% [{status}]")

          # Resumen
          print("\n" + "="*60)
          print("FX PERFORMANCE SUMMARY (1M, currency appreciation vs USD)")
          print(f"Reference date: {today_str} (yesterday = confirmed ECB rate)")
          print("="*60)
          sorted_results = sorted(
              [(c, d['fxPerformance1M']) for c, d in results.items() if d['fxPerformance1M'] is not None],
              key=lambda x: x[1], reverse=True
          )
          for curr, perf in sorted_results:
              bar = '‚ñà' * min(int(abs(perf)), 20)
              sign = '+' if perf >= 0 else ''
              print(f"  {curr}: {sign}{perf:+.2f}%  {bar}")

          # Alertar sobre nulls
          nulls = [c for c, d in results.items() if d['fxPerformance1M'] is None]
          if nulls:
              print(f"\n‚ö†Ô∏è  NULL results (API failures): {', '.join(nulls)}")
              print("   Estas divisas no contribuir√°n a su fxPerformance1M score.")
          else:
              print(f"\n‚úÖ Todas las divisas procesadas correctamente.")
          EOFPYTHON

      - name: Commit and push
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add fx-performance/
          if git diff --quiet && git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "üìà FX performance update $(date +'%Y-%m-%d') ‚Äî ECB date normalized, DXY-weighted"
            git pull --rebase origin main || true
            git push
          fi
